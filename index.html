<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebAR ‚Äî Phase 3 (Career Menu) - fixed</title>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
      "mindar-image-three": "https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-three.prod.js"
    }
  }
  </script>

  <style>
    :root{--accent:#00ffff}
    html,body{height:100%;margin:0;background:#000;color:#fff;overflow:hidden;font-family:Inter,system-ui,Arial;}
    #container{position:fixed;inset:0;display:none;background:#000;}
    /* loading */
    #loading-screen{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:999;background:linear-gradient(180deg,#020202,#000);}
    .bar-wrap{width:84%;max-width:440px;height:12px;background:rgba(255,255,255,0.06);border-radius:8px;overflow:hidden;margin-bottom:16px}
    .bar{height:100%;width:0%;background:linear-gradient(90deg,var(--accent),#0077ff);transition:width .25s;}
    #loading-text{color:#cbd5e1;margin-bottom:14px}
    #startButton{display:none;padding:12px 22px;border-radius:10px;border:none;background:var(--accent);color:#000;font-weight:600;cursor:pointer}
    /* scan frame (initial) */
    #scan-frame{position:absolute;inset:0;pointer-events:none;display:flex;align-items:center;justify-content:center;z-index:20}
    .frame{width:68vmin;height:68vmin;border-radius:12px;border:3px solid rgba(0,255,255,.14);box-shadow:0 0 30px rgba(0,255,255,.06);display:flex;align-items:center;justify-content:center}
    .corner{position:absolute;width:64px;height:64px;border:3px solid var(--accent);box-shadow:0 0 8px var(--accent);opacity:.9}
    .corner.tl{top:calc(50% - 34vmin);left:calc(50% - 34vmin);border-right:none;border-bottom:none}
    .corner.tr{top:calc(50% - 34vmin);right:calc(50% - 34vmin);border-left:none;border-bottom:none}
    .corner.bl{bottom:calc(50% - 34vmin);left:calc(50% - 34vmin);border-right:none;border-top:none}
    .corner.br{bottom:calc(50% - 34vmin);right:calc(50% - 34vmin);border-left:none;border-top:none}

    /* career menu: vertical, centered nice card */
    #career-menu{
      position:fixed;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      min-width:240px;
      max-width:360px;
      background:rgba(10,10,12,0.78);
      border:1px solid rgba(0,255,255,0.12);
      box-shadow:0 10px 30px rgba(0,0,0,0.6), 0 0 20px rgba(0,255,255,0.05);
      padding:20px;
      border-radius:14px;
      z-index:150;
      display:none;
      flex-direction:column;
      align-items:center;
      gap:10px;
      backdrop-filter: blur(6px);
    }
    #career-menu h2{margin:0;color:var(--accent); font-size:20px; text-shadow:0 0 6px rgba(0,188,212,0.15);}
    .career-list{display:flex;flex-direction:column;width:100%;gap:10px;margin-top:8px;}
    .career-btn{width:100%;padding:12px;border-radius:10px;border:none;background:linear-gradient(90deg,#0077ff,#00bcd4);color:#000;font-weight:700;cursor:pointer;box-shadow:0 6px 18px rgba(0,188,212,0.08);transition:transform .12s}
    .career-btn:active{transform:translateY(1px);}

    /* career actions (shown after selecting a career except Computer) */
    #career-actions{width:100%;display:none;flex-direction:column;gap:8px;margin-top:8px}
    .action-btn{width:100%;padding:10px;border-radius:10px;border:none;background:rgba(255,255,255,0.06);color:#fff;font-weight:700;cursor:pointer}

    /* return button at bottom of card */
    #return-row{width:100%;margin-top:6px;display:flex;justify-content:center}
    #return-btn{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.03);color:#fff;cursor:pointer}

    /* back top-left */
    #backBtn{position:fixed;left:12px;top:12px;display:none;z-index:200;padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(0,0,0,0.5);color:var(--accent);cursor:pointer}
  </style>
</head>
<body>
  <!-- LOADING -->
  <div id="loading-screen" aria-hidden="false">
    <div class="bar-wrap"><div id="bar" class="bar"></div></div>
    <div id="loading-text">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£... 0%</div>
    <button id="startButton">‡πÅ‡∏ï‡∏∞‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏° AR</button>
  </div>

  <!-- AR canvas container -->
  <div id="container"></div>

  <!-- scan overlay -->
  <div id="scan-frame" style="display:none;">
    <div class="frame"><div class="corner tl"></div><div class="corner tr"></div><div class="corner bl"></div><div class="corner br"></div></div>
  </div>

  <!-- Career menu (centered vertical) -->
  <div id="career-menu">
    <h2>‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏≤‡∏ä‡∏µ‡∏û</h2>
    <div class="career-list">
      <button class="career-btn" data-career="AI">AI</button>
      <button class="career-btn" data-career="Cloud">Cloud</button>
      <button class="career-btn" data-career="Data_Center">Data Center</button>
      <button class="career-btn" data-career="Network">Network</button>
    </div>

    <!-- action buttons appear when a non-Computer career is active -->
    <div id="career-actions">
      <button id="game-btn" class="action-btn">üéÆ Memory Match Game</button>
      <button id="survey-btn" class="action-btn">üìù ‡πÅ‡∏ö‡∏ö‡∏™‡∏≥‡∏£‡∏ß‡∏à (Google Form)</button>
      <button id="contact-btn" class="action-btn">üìû ‡∏´‡∏≤‡∏Å‡∏™‡∏ô‡πÉ‡∏à‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠</button>
    </div>

    <div id="return-row">
      <button id="return-btn">‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÄ‡∏•‡πà‡∏ô‡∏Ñ‡∏≠‡∏ô‡πÄ‡∏ó‡∏ô‡∏ï‡πå‡πÄ‡∏î‡∏¥‡∏°</button>
    </div>
  </div>

  <button id="backBtn">‚Üê ‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö</button>

  <script type="module">
  import * as THREE from 'three';
  import { MindARThree } from 'mindar-image-three';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

  // ---------- CONFIG ----------
  const JOB_ROOT = './Job';
  const careers = ['Computer','AI','Cloud','Data_Center','Network'];

  const candidates = {
    Computer: { model: ['Computer-Model.glb','computer-model.glb','Computer-model.glb'], video: ['Computer.mp4','computer.mp4','Computer-Video.mp4'] },
    AI:       { model: ['ai-model.glb','AI-model.glb','ai-model.GLTF','AI-Model.glb'], video: ['Al.mp4','AI.mp4','ai.mp4','ai-video.mp4'] },
    Cloud:    { model: ['cloud-model.glb','Cloud-model.glb','cloud-model.GLTF'], video: ['video-cloud.mp4','cloud.mp4','cloud-video.mp4'] },
    Data_Center: { model: ['Data_Center-model.glb','Data_Center-model.glb','Data_ Center-model.glb','Data_Center-model.GLTF'], video: ['Data_Center-Video.mp4','data_center.mp4','data-center.mp4'] },
    Network:  { model: ['network-model.glb','Network-model.glb','network-model.GLTF'], video: ['video-network.mp4','network.mp4','network-video.mp4'] },
  };

  // assets storage
  const assets = {};
  const bar = document.getElementById('bar');
  const loadingText = document.getElementById('loading-text');
  const startButton = document.getElementById('startButton');
  const loadingScreen = document.getElementById('loading-screen');
  const container = document.getElementById('container');
  const scanFrame = document.getElementById('scan-frame');
  const careerMenu = document.getElementById('career-menu');
  const backBtn = document.getElementById('backBtn');
  const returnBtn = document.getElementById('return-btn');
  const careerActions = document.getElementById('career-actions');
  const gameBtn = document.getElementById('game-btn');
  const surveyBtn = document.getElementById('survey-btn');
  const contactBtn = document.getElementById('contact-btn');

  // state
  let mindarThree, renderer, scene, camera;
  let anchor;
  let anchorContent = null; // <-- container for current content (so it inherits anchor.group rotation reliably)
  let gltfModel = null;
  let videoElem = null;
  let videoMesh = null;
  let mixer = null;
  let clock = new THREE.Clock();
  let playingCareer = null;   // currently playing career name (string) or null
  let lastCareer = null;      // last career chosen/played
  let isPausedByBack = false; // true if paused via Back button

  // --- variables for smooth look-at & alignment (added) ---
  const tmpObj = new THREE.Object3D();
  const tmpQuat = new THREE.Quaternion();
  const parentWorldQuat = new THREE.Quaternion();
  const targetLocalQuat = new THREE.Quaternion();
  const bbox = new THREE.Box3();
  const tmpVec = new THREE.Vector3();
  const worldMin = new THREE.Vector3();
  const worldPos = new THREE.Vector3();
  const SMOOTH_FACTOR = 0.12; // 0..1 (bigger = snappier, smaller = smoother)

  // helpers
  async function findAndFetch(career, list) {
    for (const name of list) {
      const url = `${JOB_ROOT}/${career}/${name}`;
      try {
        const res = await fetch(url, { method: 'GET' });
        if (!res.ok) continue;
        const blob = await res.blob();
        return { blob, url };
      } catch (e) { /* try next */ }
    }
    return null;
  }

  async function preloadAll() {
    let total = careers.length * 2;
    let done = 0;
    function tick() {
      done++;
      const pct = Math.round((done / total) * 100);
      bar.style.width = pct + '%';
      loadingText.textContent = `‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£... ${pct}%`;
    }

    for (const career of careers) {
      assets[career] = { modelBlobUrl: null, videoBlobUrl: null };
      const m = await findAndFetch(career, candidates[career].model);
      if (m && m.blob && m.blob.size>0) assets[career].modelBlobUrl = URL.createObjectURL(m.blob);
      else console.warn(`‡πÑ‡∏°‡πà‡∏û‡∏ö model ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ${career} -> ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏ô ${JOB_ROOT}/${career}`);
      tick();

      const v = await findAndFetch(career, candidates[career].video);
      if (v && v.blob && v.blob.size>0) assets[career].videoBlobUrl = URL.createObjectURL(v.blob);
      else console.warn(`‡πÑ‡∏°‡πà‡∏û‡∏ö video ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ${career} -> ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏ô ${JOB_ROOT}/${career}`);
      tick();
    }
    bar.style.width = '100%';
    loadingText.textContent = '‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß';
  }

  function createLights(scene) {
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
    hemi.position.set(0,1,0);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff,1);
    dir.position.set(0,1,1);
    scene.add(dir);
  }

  function loadGLTF(blobUrl) {
    return new Promise((resolve) => {
      if (!blobUrl) return resolve(null);
      const loader = new GLTFLoader();
      loader.load(blobUrl, (gltf) => resolve(gltf), undefined, (err)=>{ console.warn('GLTF load err',err); resolve(null); });
    });
  }

  function makeVideoElem(blobUrl) {
    if (!blobUrl) return null;
    const v = document.createElement('video');
    v.src = blobUrl;
    v.crossOrigin = 'anonymous';
    v.playsInline = true;
    v.muted = false;
    v.loop = false;
    v.preload = 'auto';
    return v;
  }

  // remove current anchorContent and children
  function disposeAnchorContent() {
    if (anchorContent) {
      try {
        // stop mixer
        if (mixer) {
          mixer.stopAllAction();
          mixer = null;
        }
        // remove meshes
        anchorContent.traverse((c) => {
          if (c.isMesh) {
            if (c.geometry) c.geometry.dispose();
            if (c.material && c.material.map) { c.material.map.dispose(); }
            if (c.material) c.material.dispose();
          }
        });
        anchor.group.remove(anchorContent);
      } catch(e){ /* ignore */ }
      anchorContent = null;
      gltfModel = null;
      videoMesh = null;
      if (videoElem) {
        try { videoElem.pause(); videoElem.src = ''; } catch(e){}
        videoElem = null;
      }
    }
  }

  // helper to reset local rotation/quaternion for the model root (so it inherits anchor.group rotation)
  function resetLocalIdentity(obj) {
    try {
      obj.rotation.set(0,0,0);
      obj.quaternion.set(0,0,0,1);
      obj.updateMatrixWorld(true);
    } catch(e) { /* ignore */ }
  }

  function clearAnchorContent(keep=false) {
    // if keep==true, pause only
    if (keep) {
      if (videoElem) try { videoElem.pause(); } catch(e){ }
      if (mixer) try { mixer.timeScale = 0; } catch(e){}
      isPausedByBack = true;
      return;
    }
    // full remove
    disposeAnchorContent();
    isPausedByBack = false;
  }

  function attachContentToAnchor(gltf, video) {
    // fully remove previous content then create anchorContent
    disposeAnchorContent();
    anchorContent = new THREE.Object3D();
    anchor.group.add(anchorContent);
    // model
    if (gltf && gltf.scene) {
      gltfModel = gltf.scene;
      // reset local rotation so it's neutral in anchorContent local space
      resetLocalIdentity(gltfModel);
      // scale/position defaults (tweak per model if needed)
      gltfModel.scale.set(0.4,0.4,0.4);
      gltfModel.position.set(-0.25, -0.45, 0.05);
      anchorContent.add(gltfModel);

      if (gltf.animations && gltf.animations.length > 0) {
        mixer = new THREE.AnimationMixer(gltfModel);
        gltf.animations.forEach(c => mixer.clipAction(c).play());
        mixer.timeScale = 1;
      }
    }

    // video
    if (video) {
      videoElem = video;
      const texture = new THREE.VideoTexture(videoElem);
      texture.colorSpace = THREE.SRGBColorSpace;
      const plane = new THREE.PlaneGeometry(0.6, 0.6 * (16/9));
      const mat = new THREE.MeshBasicMaterial({ map: texture });
      videoMesh = new THREE.Mesh(plane, mat);
      resetLocalIdentity(videoMesh);
      videoMesh.position.set(0, -0.05, 0);
      anchorContent.add(videoMesh);

      videoElem.onloadedmetadata = () => {
        try {
          const asp = videoElem.videoWidth / videoElem.videoHeight || (9/16);
          const width = 0.6;
          const height = width / asp;
          // update plane to real aspect
          if (videoMesh.geometry) videoMesh.geometry.dispose();
          videoMesh.geometry = new THREE.PlaneGeometry(width, height);
          videoMesh.position.set(0, 0, 0);

          // align model feet to video bottom (compute in anchorContent local space)
          if (gltfModel) {
            gltfModel.updateMatrixWorld(true);
            bbox.setFromObject(gltfModel);
            // bbox.min is in world space: convert to anchorContent local
            worldMin.copy(bbox.min);
            anchorContent.worldToLocal(worldMin);
            // video world position -> anchorContent local
            worldPos.set(0,0,0);
            videoMesh.getWorldPosition(worldPos);
            anchorContent.worldToLocal(worldPos);
            const videoBottomLocalY = worldPos.y - (height/2);
            const deltaY = videoBottomLocalY - worldMin.y;
            const UP_NUDGE = 0.02;
            gltfModel.position.y += deltaY + UP_NUDGE;
            resetLocalIdentity(gltfModel); // keep local rotation identity
          }
        } catch(e){ console.warn('onloadedmetadata align err', e); }
      };

      videoElem.onended = () => {
        lastCareer = playingCareer;
        clearAnchorContent(false);
        playingCareer = null;
        isPausedByBack = false;
        careerActions.style.display = 'none';
        careerMenu.style.display = 'flex';
        backBtn.style.display = 'none';
      };
    }
  }

  // ---------- main flow ----------
  async function main() {
    await preloadAll();
    startButton.style.display = 'inline-block';
    startButton.addEventListener('click', onStartClick);
  }

  async function onStartClick() {
    try { await navigator.mediaDevices.getUserMedia({video:true,audio:true}); } catch(e){ console.warn('permission',e); }
    loadingScreen.style.display = 'none';
    container.style.display = 'block';

    // show scan frame initially (until marker found)
    scanFrame.style.display = 'flex';
    careerMenu.style.display = 'none'; // ensure menu hidden at start

    mindarThree = new MindARThree({
      container: container,
      imageTargetSrc: `${JOB_ROOT}/Computer/marker.mind`,
      sticky: true,
      filterMinCF: 0.0001,
      filterBeta: 0.005
    });
    ({renderer, scene, camera} = mindarThree);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    createLights(scene);
    anchor = mindarThree.addAnchor(0);

    // attach Computer (initial) from preloaded assets (so it behaves like original)
    const comp = assets['Computer'] || {};
    const g = await loadGLTF(comp.modelBlobUrl);
    const v = makeVideoElem(comp.videoBlobUrl);
    attachContentToAnchor(g, v);
    playingCareer = 'Computer';
    lastCareer = 'Computer';
    careerActions.style.display = 'none';

    anchor.onTargetFound = () => {
      // hide scan UI when found
      scanFrame.style.display = 'none';
      if (videoElem && videoElem.paused) {
        try { videoElem.currentTime = 0; } catch(e){}
        const p = videoElem.play();
        if (p && p.catch) p.catch(e=>console.warn('play prevented',e));
      }
      if (mixer && isPausedByBack) {
        try { mixer.timeScale = 1; } catch(e){}
      }
      isPausedByBack = false;
    };

    anchor.onTargetLost = () => {
      // sticky: do not immediately remove content; show scanFrame so user can re-scan if needed
      // Only show scan frame if menu is not visible
      if (careerMenu.style.display === 'none') scanFrame.style.display = 'flex';
    };

    await mindarThree.start();
    renderer.setAnimationLoop(()=> {
      const delta = clock.getDelta();
      if (mixer) mixer.update(delta);

      // --- SMOOTH LOOK-AT (make anchor.group rotate smoothly to face camera) ---
      try {
        if (anchor && anchor.group && camera) {
          tmpObj.position.copy(anchor.group.getWorldPosition(new THREE.Vector3()));
          tmpObj.lookAt(camera.position);
          tmpObj.updateMatrixWorld();
          tmpObj.getWorldQuaternion(tmpQuat); // world quaternion that faces camera

          // convert world quaternion to anchor.group local quaternion
          if (anchor.group.parent) {
            anchor.group.parent.getWorldQuaternion(parentWorldQuat);
            parentWorldQuat.invert();
            targetLocalQuat.copy(parentWorldQuat).multiply(tmpQuat);
          } else {
            targetLocalQuat.copy(tmpQuat);
          }

          // slerp current quaternion -> targetLocalQuat (smooth)
          anchor.group.quaternion.slerp(targetLocalQuat, SMOOTH_FACTOR);
        }
      } catch(e) { /* non-fatal */ }

      renderer.render(scene, camera);
    });
  }

  // ---------- career interactions ----------
  async function playCareer(career) {
    // When user chooses career: close menu, remove current content, attach selected content immediately (no re-scan)
    // If you want re-scan-before-play behavior, we can change this; current choice: play immediately and rely on sticky/anchor presence.

    backBtn.style.display = 'inline-block';
    careerMenu.style.display = 'none';
    // show actions for non-Computer
    careerActions.style.display = (career !== 'Computer') ? 'flex' : 'none';

    // remove existing content fully
    clearAnchorContent(false);

    // load assets for this career
    const a = assets[career] || {};
    const gltf = await loadGLTF(a.modelBlobUrl);
    const vid = makeVideoElem(a.videoBlobUrl);

    attachContentToAnchor(gltf, vid);

    playingCareer = career;
    lastCareer = career;
    isPausedByBack = false;

    // if marker already visible -> play immediately
    try {
      if (videoElem) {
        try{ videoElem.currentTime = 0; }catch{}
        const p = videoElem.play();
        if (p && p.catch) p.catch(e=>console.warn('play blocked',e));
      }
      if (mixer) try { mixer.timeScale = 1; } catch(e){}
    } catch(e){}
  }

  function pauseAndShowMenu() {
    // pause current and show menu (menu disables scan by hiding scanFrame)
    if (videoElem) {
      try { videoElem.pause(); } catch(e){ console.warn(e); }
    }
    if (mixer) {
      try { mixer.timeScale = 0; } catch(e){ console.warn(e); }
    }
    isPausedByBack = true;
    careerActions.style.display = (playingCareer && playingCareer !== 'Computer') ? 'flex' : 'none';
    careerMenu.style.display = 'flex';
    backBtn.style.display = 'none';
    scanFrame.style.display = 'none';
  }

  function returnToLast() {
    if (!lastCareer) return;
    if (playingCareer === lastCareer && isPausedByBack && videoElem) {
      careerMenu.style.display = 'flex';
      backBtn.style.display = 'inline-block';
      isPausedByBack = false;
      try { videoElem.play(); } catch(e){ console.warn(e); }
      if (mixer) try { mixer.timeScale = 1; } catch(e){}
      if (lastCareer !== 'Computer') careerActions.style.display = 'flex';
      return;
    }
    playCareer(lastCareer);
  }

  function removeCurrentAndShowMenu() {
    clearAnchorContent(false);
    playingCareer = null;
    isPausedByBack = false;
    careerActions.style.display = 'none';
    careerMenu.style.display = 'flex';
    backBtn.style.display = 'none';
    scanFrame.style.display = 'none';
  }

  // wire UI
  document.querySelectorAll('.career-btn').forEach(btn=>{
    btn.addEventListener('click', ()=> {
      const c = btn.dataset.career;
      playCareer(c);
    });
  });

  backBtn.addEventListener('click', ()=> {
    pauseAndShowMenu();
  });

  returnBtn.addEventListener('click', ()=> {
    returnToLast();
  });

  gameBtn.addEventListener('click', ()=> {
    careerMenu.style.display = 'none';
    backBtn.style.display = 'inline-block';
    window.open('game.html', '_blank');
  });
  surveyBtn.addEventListener('click', ()=> {
    careerMenu.style.display = 'none';
    backBtn.style.display = 'inline-block';
    window.open('https://forms.gle/', '_blank');
  });
  contactBtn.addEventListener('click', ()=> {
    careerMenu.style.display = 'none';
    backBtn.style.display = 'inline-block';
    window.open('#', '_blank');
  });

  // start
  main();
  </script>
</body>
</html>
