<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebAR ‚Äî Phase 3 (Career Menu)</title>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
      "mindar-image-three": "https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-three.prod.js"
    }
  }
  </script>

  <style>
    :root{--accent:#00ffff}
    html,body{height:100%;margin:0;background:#000;color:#fff;overflow:hidden;font-family:Inter,system-ui,Arial;}
    #container{position:fixed;inset:0;display:none;background:#000;}
    /* loading */
    #loading-screen{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:999;background:linear-gradient(180deg,#020202,#000);}
    .bar-wrap{width:84%;max-width:440px;height:12px;background:rgba(255,255,255,0.06);border-radius:8px;overflow:hidden;margin-bottom:16px}
    .bar{height:100%;width:0%;background:linear-gradient(90deg,var(--accent),#0077ff);transition:width .25s;}
    #loading-text{color:#cbd5e1;margin-bottom:14px}
    #startButton{display:none;padding:12px 22px;border-radius:10px;border:none;background:var(--accent);color:#000;font-weight:600;cursor:pointer}
    /* scan frame (initial) */
    #scan-frame{position:absolute;inset:0;pointer-events:none;display:flex;align-items:center;justify-content:center;z-index:20}
    .frame{width:68vmin;height:68vmin;border-radius:12px;border:3px solid rgba(0,255,255,.14);box-shadow:0 0 30px rgba(0,255,255,.06);display:flex;align-items:center;justify-content:center}
    .corner{position:absolute;width:64px;height:64px;border:3px solid var(--accent);box-shadow:0 0 8px var(--accent);opacity:.9}
    .corner.tl{top:calc(50% - 34vmin);left:calc(50% - 34vmin);border-right:none;border-bottom:none}
    .corner.tr{top:calc(50% - 34vmin);right:calc(50% - 34vmin);border-left:none;border-bottom:none}
    .corner.bl{bottom:calc(50% - 34vmin);left:calc(50% - 34vmin);border-right:none;border-top:none}
    .corner.br{bottom:calc(50% - 34vmin);right:calc(50% - 34vmin);border-left:none;border-top:none}

    /* career menu: vertical, centered nice card */
    #career-menu{
      position:fixed;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      min-width:240px;
      max-width:360px;
      background:rgba(10,10,12,0.78);
      border:1px solid rgba(0,255,255,0.12);
      box-shadow:0 10px 30px rgba(0,0,0,0.6), 0 0 20px rgba(0,255,255,0.05);
      padding:20px;
      border-radius:14px;
      z-index:150;
      display:none;
      flex-direction:column;
      align-items:center;
      gap:10px;
      backdrop-filter: blur(6px);
    }
    #career-menu h2{margin:0;color:var(--accent); font-size:20px; text-shadow:0 0 6px rgba(0,188,212,0.15);}
    .career-list{display:flex;flex-direction:column;width:100%;gap:10px;margin-top:8px;}
    .career-btn{width:100%;padding:12px;border-radius:10px;border:none;background:linear-gradient(90deg,#0077ff,#00bcd4);color:#000;font-weight:700;cursor:pointer;box-shadow:0 6px 18px rgba(0,188,212,0.08);transition:transform .12s}
    .career-btn:active{transform:translateY(1px);}

    /* career actions (shown after selecting a career except Computer) */
    #career-actions{width:100%;display:none;flex-direction:column;gap:8px;margin-top:8px}
    .action-btn{width:100%;padding:10px;border-radius:10px;border:none;background:rgba(255,255,255,0.06);color:#fff;font-weight:700;cursor:pointer}

    /* return button at bottom of card */
    #return-row{width:100%;margin-top:6px;display:flex;justify-content:center}
    #return-btn{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.03);color:#fff;cursor:pointer}

    /* back top-left */
    #backBtn{position:fixed;left:12px;top:12px;display:none;z-index:200;padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(0,0,0,0.5);color:var(--accent);cursor:pointer}
  </style>
</head>
<body>
  <!-- LOADING -->
  <div id="loading-screen" aria-hidden="false">
    <div class="bar-wrap"><div id="bar" class="bar"></div></div>
    <div id="loading-text">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£... 0%</div>
    <button id="startButton">‡πÅ‡∏ï‡∏∞‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏° AR</button>
  </div>

  <!-- AR canvas container -->
  <div id="container"></div>

  <!-- scan overlay -->
  <div id="scan-frame">
    <div class="frame"><div class="corner tl"></div><div class="corner tr"></div><div class="corner bl"></div><div class="corner br"></div></div>
  </div>

  <!-- Career menu (centered vertical) -->
  <div id="career-menu">
    <h2>‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏≤‡∏ä‡∏µ‡∏û</h2>
    <div class="career-list">
      <button class="career-btn" data-career="AI">AI</button>
      <button class="career-btn" data-career="Cloud">Cloud</button>
      <button class="career-btn" data-career="Data_Center">Data Center</button>
      <button class="career-btn" data-career="Network">Network</button>
    </div>

    <!-- action buttons appear when a non-Computer career is active -->
    <div id="career-actions">
      <button id="game-btn" class="action-btn">üéÆ Memory Match Game</button>
      <button id="survey-btn" class="action-btn">üìù ‡πÅ‡∏ö‡∏ö‡∏™‡∏≥‡∏£‡∏ß‡∏à (Google Form)</button>
      <button id="contact-btn" class="action-btn">üìû ‡∏´‡∏≤‡∏Å‡∏™‡∏ô‡πÉ‡∏à‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠</button>
    </div>

    <div id="return-row">
      <button id="return-btn">‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÄ‡∏•‡πà‡∏ô‡∏Ñ‡∏≠‡∏ô‡πÄ‡∏ó‡∏ô‡∏ï‡πå‡πÄ‡∏î‡∏¥‡∏°</button>
    </div>
  </div>

  <button id="backBtn">‚Üê ‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö</button>

  <script type="module">
  import * as THREE from 'three';
  import { MindARThree } from 'mindar-image-three';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

  // ---------- CONFIG ----------
  const JOB_ROOT = './Job';
  const careers = ['Computer','AI','Cloud','Data_Center','Network'];

  const candidates = {
    Computer: { model: ['Computer-Model.glb','computer-model.glb','Computer-model.glb'], video: ['Computer.mp4','computer.mp4','Computer-Video.mp4'] },
    AI:       { model: ['ai-model.glb','AI-model.glb','ai-model.GLTF','AI-Model.glb'], video: ['Al.mp4','AI.mp4','ai.mp4','ai-video.mp4'] },
    Cloud:    { model: ['cloud-model.glb','Cloud-model.glb','cloud-model.GLTF'], video: ['video-cloud.mp4','cloud.mp4','cloud-video.mp4'] },
    Data_Center: { model: ['Data_Center-model.glb','Data_Center-model.glb','Data_ Center-model.glb','Data_Center-model.GLTF'], video: ['Data_Center-Video.mp4','data_center.mp4','data-center.mp4'] },
    Network:  { model: ['network-model.glb','Network-model.glb','network-model.GLTF'], video: ['video-network.mp4','network.mp4','network-video.mp4'] },
  };

  // assets storage
  const assets = {};
  const bar = document.getElementById('bar');
  const loadingText = document.getElementById('loading-text');
  const startButton = document.getElementById('startButton');
  const loadingScreen = document.getElementById('loading-screen');
  const container = document.getElementById('container');
  const scanFrame = document.getElementById('scan-frame');
  const careerMenu = document.getElementById('career-menu');
  const backBtn = document.getElementById('backBtn');
  const returnBtn = document.getElementById('return-btn');
  const careerActions = document.getElementById('career-actions');
  const gameBtn = document.getElementById('game-btn');
  const surveyBtn = document.getElementById('survey-btn');
  const contactBtn = document.getElementById('contact-btn');

  // state
  let mindarThree, renderer, scene, camera;
  let anchor;
  let gltfModel = null;
  let videoElem = null;
  let videoMesh = null;
  let mixer = null;
  let clock = new THREE.Clock();
  let playingCareer = null;   // currently playing career name (string) or null
  let lastCareer = null;      // last career chosen/played
  let isPausedByBack = false; // true if paused via Back button

  // helpers
  async function findAndFetch(career, list) {
    for (const name of list) {
      const url = `${JOB_ROOT}/${career}/${name}`;
      try {
        const res = await fetch(url, { method: 'GET' });
        if (!res.ok) continue;
        const blob = await res.blob();
        return { blob, url };
      } catch (e) { /* try next */ }
    }
    return null;
  }

  async function preloadAll() {
    let total = careers.length * 2;
    let done = 0;
    function tick() {
      done++;
      const pct = Math.round((done / total) * 100);
      bar.style.width = pct + '%';
      loadingText.textContent = `‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£... ${pct}%`;
    }

    for (const career of careers) {
      assets[career] = { modelBlobUrl: null, videoBlobUrl: null };
      const m = await findAndFetch(career, candidates[career].model);
      if (m && m.blob && m.blob.size>0) assets[career].modelBlobUrl = URL.createObjectURL(m.blob);
      else console.warn(`‡πÑ‡∏°‡πà‡∏û‡∏ö model ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ${career} -> ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏ô ${JOB_ROOT}/${career}`);
      tick();

      const v = await findAndFetch(career, candidates[career].video);
      if (v && v.blob && v.blob.size>0) assets[career].videoBlobUrl = URL.createObjectURL(v.blob);
      else console.warn(`‡πÑ‡∏°‡πà‡∏û‡∏ö video ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ${career} -> ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏ô ${JOB_ROOT}/${career}`);
      tick();
    }
    bar.style.width = '100%';
    loadingText.textContent = '‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß';
  }

  function createLights(scene) {
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
    hemi.position.set(0,1,0);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff,1);
    dir.position.set(0,1,1);
    scene.add(dir);
  }

  function loadGLTF(blobUrl) {
    return new Promise((resolve) => {
      if (!blobUrl) return resolve(null);
      const loader = new GLTFLoader();
      loader.load(blobUrl, (gltf) => resolve(gltf), undefined, (err)=>{ console.warn('GLTF load err',err); resolve(null); });
    });
  }

  function makeVideoElem(blobUrl) {
    if (!blobUrl) return null;
    const v = document.createElement('video');
    v.src = blobUrl;
    v.crossOrigin = 'anonymous';
    v.playsInline = true;
    v.muted = false;
    v.loop = false;
    v.preload = 'auto';
    return v;
  }

  function clearAnchorContent(keep=false) {
    // if keep==true, we keep elements but pause video & animations (used when pressing Back)
    if (keep) {
      if (videoElem) {
        try { videoElem.pause(); } catch(e){}
      }
      if (mixer) {
        try { mixer.timeScale = 0; } catch(e){}
      }
      isPausedByBack = true;
      return;
    }

    // full remove: stop animation mixer properly
    if (mixer) {
      try { mixer.stopAllAction(); } catch(e){}
      mixer = null;
    }
    if (gltfModel) { try{ anchor.group.remove(gltfModel); }catch{} gltfModel = null; }
    if (videoMesh) { try{ anchor.group.remove(videoMesh); }catch{} videoMesh = null; }
    if (videoElem) { try{ videoElem.pause(); videoElem.src = ''; }catch{} videoElem = null; }
  }

  function attachContentToAnchor(gltf, video) {
    // remove existing (but do not remove if we're intentionally reusing - handled by caller)
    if (gltfModel) { try{ anchor.group.remove(gltfModel); } catch(e){} gltfModel = null; }
    if (videoMesh) { try{ anchor.group.remove(videoMesh); } catch(e){} videoMesh = null; }
    if (videoElem) { try{ videoElem.pause(); } catch(e){} videoElem = null; }
    mixer = null;

    // model
    if (gltf && gltf.scene) {
      gltfModel = gltf.scene;
      gltfModel.scale.set(0.4,0.4,0.4);
      // position front-left-bottom relative to video (set approximate)
      gltfModel.position.set(-0.25, 0 , 0.05);
      anchor.group.add(gltfModel);
      if (gltf.animations && gltf.animations.length > 0) {
        mixer = new THREE.AnimationMixer(gltfModel);
        gltf.animations.forEach(c => mixer.clipAction(c).play());
        mixer.timeScale = 1; // ensure playing
      }
    }

    // video
    if (video) {
      videoElem = video;
      const texture = new THREE.VideoTexture(videoElem);
      texture.colorSpace = THREE.SRGBColorSpace;
      // default portrait plane (will fix on metadata)
      const plane = new THREE.PlaneGeometry(0.6, 0.6 * (16/9));
      const mat = new THREE.MeshBasicMaterial({ map: texture });
      videoMesh = new THREE.Mesh(plane, mat);
      videoMesh.position.set(0, -0.05, 0);
      anchor.group.add(videoMesh);

      videoElem.onloadedmetadata = () => {
        try {
          const asp = videoElem.videoWidth / videoElem.videoHeight || (9/16);
          const width = 0.6;
          const height = width / asp;
          videoMesh.geometry.dispose();
          videoMesh.geometry = new THREE.PlaneGeometry(width, height);
          videoMesh.position.set(0, 0, 0);
          if (gltfModel) gltfModel.position.set(-0.25, -height/2 - 0.1, 0.05);
        } catch(e){}
      };

      // when career video ends -> cleanup and show menu
      videoElem.onended = () => {
        // set lastCareer to the career that just finished (playingCareer)
        lastCareer = playingCareer;
        // fully remove content
        clearAnchorContent(false);
        playingCareer = null;
        isPausedByBack = false;
        // show menu (and hide actions)
        careerActions.style.display = 'none';
        careerMenu.style.display = 'flex';
        backBtn.style.display = 'none';
      };
    }
  }

  // ---------- main flow ----------
  async function main() {
    await preloadAll();
    startButton.style.display = 'inline-block';
    startButton.addEventListener('click', onStartClick);
  }

  async function onStartClick() {
    try { await navigator.mediaDevices.getUserMedia({video:true,audio:true}); } catch(e){ console.warn('permission',e); }
    loadingScreen.style.display = 'none';
    container.style.display = 'block';
    scanFrame.style.display = 'flex';

    mindarThree = new MindARThree({
      container: container,
      imageTargetSrc: `${JOB_ROOT}/Computer/marker.mind`,
      sticky: true,
      filterMinCF: 0.0001,
      filterBeta: 0.005
    });
    ({renderer, scene, camera} = mindarThree);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    createLights(scene);
    anchor = mindarThree.addAnchor(0);

    // attach Computer (initial) from preloaded assets
    const comp = assets['Computer'] || {};
    const g = await loadGLTF(comp.modelBlobUrl);
    const v = makeVideoElem(comp.videoBlobUrl);
    attachContentToAnchor(g, v);
    playingCareer = 'Computer';
    lastCareer = 'Computer';
    careerActions.style.display = 'none';

    // on target found -> start video (synchronized)
    anchor.onTargetFound = () => {
      scanFrame.style.display = 'none';
      if (videoElem && videoElem.paused) {
        try { videoElem.currentTime = 0; } catch(e){}
        const p = videoElem.play();
        if (p && p.catch) p.catch(e=>console.warn('play prevented',e));
      }
      // resume animations if paused by back
      if (mixer && isPausedByBack) {
        try { mixer.timeScale = 1; } catch(e){}
      }
      isPausedByBack = false;
    };

    anchor.onTargetLost = () => {
      // sticky: do nothing, content remains visible at last transform
      scanFrame.style.display = 'none';
    };

    await mindarThree.start();
    renderer.setAnimationLoop(()=> {
      const delta = clock.getDelta();
      if (mixer) mixer.update(delta);
      renderer.render(scene, camera);
      anchor.group.lookAt(camera.position);
    });

    // when Computer video ends -> remove and show menu (attachContentToAnchor already handles onended)
  }

  // ---------- career interactions ----------
  async function playCareer(career) {
    // Called when user selects a career from menu

    // show back button (to pause/return)
    backBtn.style.display = 'inline-block';

    // show actions for non-Computer (we still prepare them, but menu will be hidden as requested)
    if (career !== 'Computer') {
      careerActions.style.display = 'flex';
    } else {
      careerActions.style.display = 'none';
    }

    // close the career menu (user requested: after selecting, close the selection card)
    careerMenu.style.display = 'none';

    // if same career already playing and paused -> resume
    if (playingCareer === career && isPausedByBack && videoElem) {
      isPausedByBack = false;
      // resume video + animations
      try { videoElem.play(); } catch(e){ console.warn(e); }
      if (mixer) try { mixer.timeScale = 1; } catch(e){}
      return;
    }

    // if another career currently playing -> remove it fully
    if (playingCareer && playingCareer !== career) {
      clearAnchorContent(false);
      playingCareer = null;
      isPausedByBack = false;
    }

    // load assets for this career
    const a = assets[career] || {};
    const gltf = await loadGLTF(a.modelBlobUrl);
    const vid = makeVideoElem(a.videoBlobUrl);

    attachContentToAnchor(gltf, vid);

    // set states
    playingCareer = career;
    lastCareer = career;
    isPausedByBack = false;

    // if marker already visible/sticky -> play immediately
    try {
      if (videoElem) {
        try{ videoElem.currentTime = 0; }catch{}
        const p = videoElem.play();
        if (p && p.catch) p.catch(e=>console.warn('play blocked',e));
      }
      if (mixer) try { mixer.timeScale = 1; } catch(e){}
    } catch(e){}
  }

  function pauseAndShowMenu() {
    // Back button behavior from content -> pause current (keep in scene), show menu
    if (videoElem) {
      try { videoElem.pause(); } catch(e){ console.warn(e); }
    }
    if (mixer) {
      try { mixer.timeScale = 0; } catch(e){ console.warn(e); }
    }
    isPausedByBack = true;
    // show career-actions while in menu only if a non-Computer career is paused
    careerActions.style.display = (playingCareer && playingCareer !== 'Computer') ? 'flex' : 'none';
    careerMenu.style.display = 'flex';
    backBtn.style.display = 'none';
  }

  function returnToLast() {
    // Called when pressing Return in menu: resume lastCareer
    if (!lastCareer) return;
    // if current attached content is lastCareer and paused => resume
    if (playingCareer === lastCareer && isPausedByBack && videoElem) {
      careerMenu.style.display = 'flex';
      backBtn.style.display = 'inline-block';
      isPausedByBack = false;
      try { videoElem.play(); } catch(e){ console.warn(e); }
      if (mixer) try { mixer.timeScale = 1; } catch(e){}
      // show actions if lastCareer is not Computer
      if (lastCareer !== 'Computer') careerActions.style.display = 'flex';
      return;
    }
    // else, (re)play lastCareer from start
    playCareer(lastCareer);
  }

  function removeCurrentAndShowMenu() {
    // utility to remove current playing content fully and show menu
    clearAnchorContent(false);
    playingCareer = null;
    isPausedByBack = false;
    careerActions.style.display = 'none';
    careerMenu.style.display = 'flex';
    backBtn.style.display = 'none';
  }

  // wire UI
  document.querySelectorAll('.career-btn').forEach(btn=>{
    btn.addEventListener('click', ()=> {
      const c = btn.dataset.career;
      playCareer(c);
    });
  });

  backBtn.addEventListener('click', ()=> {
    // pause current and return to menu
    pauseAndShowMenu();
  });

  returnBtn.addEventListener('click', ()=> {
    returnToLast();
  });

  // action buttons behavior (placeholders - replace URLs as needed)
  gameBtn.addEventListener('click', ()=> {
    // close menu if visible, then open game
    careerMenu.style.display = 'none';
    backBtn.style.display = 'inline-block';
    window.open('game.html', '_blank');
  });
  surveyBtn.addEventListener('click', ()=> {
    careerMenu.style.display = 'none';
    backBtn.style.display = 'inline-block';
    window.open('https://forms.gle/', '_blank');
  });
  contactBtn.addEventListener('click', ()=> {
    careerMenu.style.display = 'none';
    backBtn.style.display = 'inline-block';
    window.open('#', '_blank');
  });

  // start
  main();

  </script>
</body>
</html>
