<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebAR — Phase 3 (Career Menu)</title>

  <!-- importmap + modules -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
      "mindar-image-three": "https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-three.prod.js"
    }
  }
  </script>

  <style>
    :root{--accent:#00ffff}
    html,body{height:100%;margin:0;background:#000;color:#fff;overflow:hidden;font-family:Inter,system-ui,Arial;}
    #container{position:fixed;inset:0;display:none;background:#000;}
    /* loading */
    #loading-screen{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:999;background:linear-gradient(180deg,#020202,#000);}
    .bar-wrap{width:84%;max-width:440px;height:12px;background:rgba(255,255,255,0.06);border-radius:8px;overflow:hidden;margin-bottom:16px}
    .bar{height:100%;width:0%;background:linear-gradient(90deg,var(--accent),#0077ff);transition:width .25s;}
    #loading-text{color:#cbd5e1;margin-bottom:14px}
    #startButton{display:none;padding:12px 22px;border-radius:10px;border:none;background:var(--accent);color:#000;font-weight:600;cursor:pointer}
    /* scan frame (initial) */
    #scan-frame{position:absolute;inset:0;pointer-events:none;display:flex;align-items:center;justify-content:center;z-index:20}
    .frame{width:68vmin;height:68vmin;border-radius:12px;border:3px solid rgba(0,255,255,.14);box-shadow:0 0 30px rgba(0,255,255,.06);display:flex;align-items:center;justify-content:center}
    .corner{position:absolute;width:64px;height:64px;border:3px solid var(--accent);box-shadow:0 0 8px var(--accent);opacity:.9}
    .corner.tl{top:calc(50% - 34vmin);left:calc(50% - 34vmin);border-right:none;border-bottom:none}
    .corner.tr{top:calc(50% - 34vmin);right:calc(50% - 34vmin);border-left:none;border-bottom:none}
    .corner.bl{bottom:calc(50% - 34vmin);left:calc(50% - 34vmin);border-right:none;border-top:none}
    .corner.br{bottom:calc(50% - 34vmin);right:calc(50% - 34vmin);border-left:none;border-top:none}
    /* career menu */
    #career-menu{position:fixed;bottom:6vh;left:50%;transform:translateX(-50%);display:none;z-index:110;gap:12px;align-items:center;flex-direction:column}
    .career-row{display:flex;gap:12px}
    .career-btn{padding:10px 16px;border-radius:10px;border:none;background:rgba(255,255,255,0.08);color:#fff;font-weight:600;cursor:pointer}
    .career-btn.primary{background:linear-gradient(90deg,var(--accent),#0077ff);color:#000}
    #backBtn{position:fixed;left:12px;top:12px;display:none;z-index:120;padding:8px 10px;border-radius:8px;border:none;background:rgba(255,255,255,.06);color:#fff;cursor:pointer}
  </style>
</head>
<body>
  <!-- LOADING -->
  <div id="loading-screen" aria-hidden="false">
    <div class="bar-wrap"><div id="bar" class="bar"></div></div>
    <div id="loading-text">กำลังโหลดทรัพยากร... 0%</div>
    <button id="startButton">แตะเพื่อเริ่ม AR</button>
  </div>

  <!-- AR canvas container -->
  <div id="container"></div>

  <!-- scan overlay -->
  <div id="scan-frame">
    <div class="frame"><div class="corner tl"></div><div class="corner tr"></div><div class="corner bl"></div><div class="corner br"></div></div>
  </div>

  <!-- Career menu (shown after Computer content finished) -->
  <div id="career-menu">
    <div style="font-weight:600;margin-bottom:8px">เลือกอาชีพ</div>
    <div class="career-row">
      <button class="career-btn" data-career="AI">AI</button>
      <button class="career-btn" data-career="Cloud">Cloud</button>
      <button class="career-btn" data-career="Data_Center">Data Center</button>
      <button class="career-btn" data-career="Network">Network</button>
    </div>
  </div>

  <button id="backBtn">← ย้อนกลับ</button>

  <script type="module">
  import * as THREE from 'three';
  import { MindARThree } from 'mindar-image-three';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

  // ---------- CONFIG ----------
  const JOB_ROOT = './Job'; // ตามที่คุณบอก: Job/Computer/... etc
  const careers = ['Computer','AI','Cloud','Data_Center','Network'];

  // Candidate filename lists (พยายามหลายชื่อเพื่อความทนทาน)
  const candidates = {
    Computer: { model: ['Computer-Model.glb','computer-model.glb','Computer-model.glb'], video: ['Computer.mp4','computer.mp4','Computer-Video.mp4'] },
    AI:       { model: ['ai-model.glb','AI-model.glb','ai-model.GLTF','AI-Model.glb'], video: ['Al.mp4','AI.mp4','ai.mp4','ai-video.mp4'] },
    Cloud:    { model: ['cloud-model.glb','Cloud-model.glb','cloud-model.GLTF'], video: ['video-cloud.mp4','cloud.mp4','cloud-video.mp4'] },
    Data_Center: { model: ['Data_Center-model.glb','Data_Center-model.glb','Data_ Center-model.glb','Data_Center-model.GLTF'], video: ['Data_Center-Video.mp4','data_center.mp4','data-center.mp4'] },
    Network:  { model: ['network-model.glb','Network-model.glb','network-model.GLTF'], video: ['video-network.mp4','network.mp4','network-video.mp4'] },
  };

  // Storage for preloaded blobs/URLs
  const assets = {}; // assets[career] = { modelBlobUrl, videoBlobUrl }

  // UI nodes
  const bar = document.getElementById('bar');
  const loadingText = document.getElementById('loading-text');
  const startButton = document.getElementById('startButton');
  const loadingScreen = document.getElementById('loading-screen');
  const container = document.getElementById('container');
  const scanFrame = document.getElementById('scan-frame');
  const careerMenu = document.getElementById('career-menu');
  const backBtn = document.getElementById('backBtn');

  // ---------- helper: try find file from candidates ----------
  async function findAndFetch(career, list) {
    for (const name of list) {
      const url = `${JOB_ROOT}/${career}/${name}`;
      try {
        const res = await fetch(url, { method: 'GET' });
        if (!res.ok) continue;
        const blob = await res.blob();
        return { blob, url };
      } catch (e) {
        // ignore, try next
      }
    }
    return null;
  }

  // ---------- Preload all careers (models + videos) ----------
  async function preloadAll() {
    let total = careers.length * 2; // model + video per career
    let done = 0;
    function tick() {
      done++;
      const pct = Math.round((done / total) * 100);
      bar.style.width = pct + '%';
      loadingText.textContent = `กำลังโหลดทรัพยากร... ${pct}%`;
    }

    for (const career of careers) {
      assets[career] = { modelBlobUrl: null, videoBlobUrl: null };

      // model
      const m = await findAndFetch(career, candidates[career].model);
      if (m && m.blob && m.blob.size>0) {
        assets[career].modelBlobUrl = URL.createObjectURL(m.blob);
      } else {
        console.warn(`ไม่พบ model สำหรับ ${career} (ลองดูชื่อไฟล์ใน ${JOB_ROOT}/${career})`);
      }
      tick();

      // video
      const v = await findAndFetch(career, candidates[career].video);
      if (v && v.blob && v.blob.size>0) {
        assets[career].videoBlobUrl = URL.createObjectURL(v.blob);
      } else {
        console.warn(`ไม่พบ video สำหรับ ${career} (ลองดูชื่อไฟล์ใน ${JOB_ROOT}/${career})`);
      }
      tick();
    }

    // ensure 100%
    bar.style.width = '100%';
    loadingText.textContent = 'โหลดเสร็จแล้ว';
  }

  // ---------- AR setup ----------
  let mindarThree, renderer, scene, camera;
  let anchor; // single anchor index 0
  let gltfModel = null;
  let videoElem = null;
  let videoMesh = null;
  let mixer = null;
  let clock = new THREE.Clock();
  let currentCareer = 'Computer';

  function createLights(scene) {
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
    hemi.position.set(0,1,0);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff,1);
    dir.position.set(0,1,1);
    scene.add(dir);
  }

  // load GLTF into anchor group using blob URL
  function loadGLTFToAnchor(blobUrl) {
    return new Promise((resolve,reject)=>{
      if(!blobUrl) return resolve(null);
      const loader = new GLTFLoader();
      loader.load(blobUrl, (gltf)=>{
        resolve(gltf);
      }, undefined, (err)=>{ console.warn('GLTF load err',err); resolve(null); });
    });
  }

  // create video element from blob URL (not autoplay until marker found)
  function createVideoElement(blobUrl) {
    if(!blobUrl) return null;
    const v = document.createElement('video');
    v.src = blobUrl;
    v.crossOrigin = 'anonymous';
    v.playsInline = true;
    v.muted = false;
    v.loop = false;
    v.preload = 'auto';
    return v;
  }

  // place model & video: video centered, model in front-left-bottom
  function attachContentToAnchor(gltf, video) {
    // clear previous
    if(gltfModel) { anchor.group.remove(gltfModel); gltfModel = null; }
    if(videoMesh) { anchor.group.remove(videoMesh); videoMesh = null; }
    if(videoElem) { try{ videoElem.pause(); }catch{} videoElem = null; }

    // add model (if any)
    if(gltf && gltf.scene) {
      gltfModel = gltf.scene;
      // scale heuristic
      gltfModel.scale.set(0.4,0.4,0.4);
      // put model front-left-bottom of video
      gltfModel.position.set(-0.25, -0.45, 0.05);
      anchor.group.add(gltfModel);
      // animations
      if(gltf.animations && gltf.animations.length > 0) {
        mixer = new THREE.AnimationMixer(gltfModel);
        gltf.animations.forEach(c => mixer.clipAction(c).play());
      }
    }

    // add video plane (portrait)
    if(video) {
      videoElem = video;
      // video aspect — try detect via metadata when canplay
      const texture = new THREE.VideoTexture(videoElem);
      texture.colorSpace = THREE.SRGBColorSpace;
      // portrait plane: width 0.6, height adjusted by aspect on play
      const plane = new THREE.PlaneGeometry(0.6, 0.6 * (16/9)); // default; we'll update on metadata
      const mat = new THREE.MeshBasicMaterial({ map: texture });
      videoMesh = new THREE.Mesh(plane, mat);
      videoMesh.position.set(0, -0.05, 0); // center in front of anchor
      anchor.group.add(videoMesh);

      // when metadata loaded, fix plane ratio
      videoElem.onloadedmetadata = () => {
        try {
          const asp = videoElem.videoWidth / videoElem.videoHeight || (9/16);
          const width = 0.6;
          const height = width / asp;
          videoMesh.geometry.dispose();
          videoMesh.geometry = new THREE.PlaneGeometry(width, height);
          // position slightly so model sits front-left-bottom
          videoMesh.position.set(0, 0, 0);
          if(gltfModel) gltfModel.position.set(-0.25, -height/2 - 0.1, 0.05);
        } catch(e) { /* ignore */ }
      };
    }
  }

  // remove computer content (cleanup)
  function removeComputerContent() {
    if(gltfModel) { anchor.group.remove(gltfModel); gltfModel = null; }
    if(videoMesh) { anchor.group.remove(videoMesh); videoMesh = null; }
    if(videoElem) { try { videoElem.pause(); videoElem.src = ''; } catch(e){} videoElem = null; }
  }

  // ---------- main flow ----------
  async function main() {
    // preload everything first
    await preloadAll();

    // show start button
    startButton.style.display = 'inline-block';
    startButton.addEventListener('click', onStartClick);
  }

  async function onStartClick() {
    // request permission to enable autoplay of audio on some browsers
    try {
      await navigator.mediaDevices.getUserMedia({video:true,audio:true});
    } catch(e){
      console.warn('Permission denied or unavailable:', e);
      // still continue (many browsers allow camera prompt later)
    }

    // hide loading, show container
    loadingScreen.style.display = 'none';
    container.style.display = 'block';
    scanFrame.style.display = 'flex'; // show scanning frame until target found

    // init MindAR
    mindarThree = new MindARThree({
      container: container,
      imageTargetSrc: `${JOB_ROOT}/Computer/marker.mind`, // we use computer marker as primary target
      sticky: true,
      filterMinCF: 0.0001,
      filterBeta: 0.005
    });
    ({renderer, scene, camera} = mindarThree);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    createLights(scene);

    anchor = mindarThree.addAnchor(0);

    // prepare Computer content from preloaded blobs
    const cAssets = assets['Computer'] || {};
    const computerModelUrl = cAssets.modelBlobUrl;
    const computerVideoUrl = cAssets.videoBlobUrl;

    // load gltf (blob url)
    const gltf = await loadGLTFToAnchor(computerModelUrl);
    const vidElem = createVideoElement(computerVideoUrl);

    attachContentToAnchor(gltf, vidElem);

    // ensure sticky: anchor.group.visible always true even if marker lost
    anchor.onTargetFound = () => {
      scanFrame.style.display = 'none';
      // play synchronization: start model animations already running via mixer; start video only now
      if(videoElem && videoElem.paused) {
        try { videoElem.currentTime = 0; } catch(e){}
        const playPromise = videoElem.play();
        if (playPromise && playPromise.catch) {
          playPromise.catch(err => console.warn('video play prevented:', err));
        }
      }
    };

    // ensure not removing when lost
    anchor.onTargetLost = () => {
      // do nothing — sticky mode keeps content visible in last transform
      // but still keep scanFrame hidden
      scanFrame.style.display = 'none';
    };

    // start renderer
    await mindarThree.start();
    renderer.setAnimationLoop( ( ) => {
      const delta = clock.getDelta();
      if(mixer) mixer.update(delta);
      renderer.render(scene, camera);
    });

    // when video ends => remove Computer content and show career menu
    if(videoElem) {
      videoElem.addEventListener('ended', onComputerEnded);
    } else {
      // if no video available: fallback show menu after 4s
      setTimeout(onComputerEnded, 4000);
    }
  }

  function onComputerEnded() {
    // cleanup computer content
    removeComputerContent();

    // show career menu
    careerMenu.style.display = 'flex';
    backBtn.style.display = 'none';
  }

  // ---------- career selection actions ----------
  async function playCareer(career) {
    // hide menu
    careerMenu.style.display = 'none';
    backBtn.style.display = 'inline-block';

    // remove any existing content in anchor
    if(gltfModel){ anchor.group.remove(gltfModel); gltfModel = null; }
    if(videoMesh){ anchor.group.remove(videoMesh); videoMesh = null; }
    if(videoElem){ try{ videoElem.pause(); }catch{} videoElem = null; }

    // get assets preloaded
    const a = assets[career] || {};
    const modelUrl = a.modelBlobUrl;
    const videoUrl = a.videoBlobUrl;

    // load and attach
    const gltf = await loadGLTFToAnchor(modelUrl);
    const vid = createVideoElement(videoUrl);
    attachContentToAnchor(gltf, vid);

    // if marker already found (sticky), play immediately
    if(vid) {
      try{ vid.currentTime = 0; }catch{}
      const p = vid.play();
      if(p && p.catch) p.catch(e => console.warn('play blocked',e));
    }
  }

  // back: stop current career content and show menu
  function goBackToMenu() {
    if(videoElem){ try{ videoElem.pause(); }catch{} }
    if(gltfModel){ anchor.group.remove(gltfModel); gltfModel = null; }
    if(videoMesh){ anchor.group.remove(videoMesh); videoMesh = null; }
    careerMenu.style.display = 'flex';
    backBtn.style.display = 'none';
  }

  // wire UI career buttons
  document.querySelectorAll('.career-btn').forEach(btn=>{
    btn.addEventListener('click', ()=> {
      const c = btn.dataset.career;
      playCareer(c);
    });
  });

  backBtn.addEventListener('click', goBackToMenu);

  // ---------- start main ----------
  main();

  </script>
</body>
</html>
